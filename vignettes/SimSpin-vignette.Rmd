---
title: "Using SimSpin"
author: "Katherine Harborne"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

``` {r, message=FALSE, warning=FALSE} 
library(SimSpin)
```

The purpose of this package is to measure the observable spin parameter $\lambda_R$ for simulated galaxy models with an effort to provide a method of communication between observers and computational astrophysicists. The aim is to address a simple question: is the true spin parameter, $\lambda$, and the one that we measure observationally, $\lambda_R$, comparable? 

This notebook will walk through a few of the basic steps that we can use to analyse a galaxy model. Here, we will use `filename = "~/SimSpin/inst/extdata/S0_vignette"` to explore the functions available in this package. This is the Gadget snapshot for a $10^{10} M_{\odot}$, S0 galaxy containing 50,000 disk and 75,000 bulge particles of equal mass. This is shown below. 

``` {r} 
galaxy_data = snapshot::snapread("~/LambdaR/inst/extdata/S0_vignette")
```

``` {r, echo=FALSE, fig.width=5, fig.height=5, fig.align="center"}
magicaxis::magplot(galaxy_data$part$x[(galaxy_data$head$Npart[3]+1):(galaxy_data$head$Npart[3]+galaxy_data$head$Npart[4])], galaxy_data$part$y[(galaxy_data$head$Npart[3]+1):(galaxy_data$head$Npart[3]+galaxy_data$head$Npart[4])], pch = '.', xlim = c(-20, 20), ylim = c(-20, 20), xlab = "x-position, kpc", ylab = "y-position, kpc", col = rgb(0, 0, 0, 0.05))
points(galaxy_data$part$x[1:galaxy_data$head$Npart[3]], galaxy_data$part$y[1:galaxy_data$head$Npart[3]], col = rgb(1, 0, 0, 0.05), pch = '.')
legend("topleft", inset=c(0.05,0.05),c("Bulge particles", "Disk particles"), col= c("black", "red"), pch= c(19, 19), bty="n", cex=0.9)

magicaxis::magplot(galaxy_data$part$x[(galaxy_data$head$Npart[3]+1):(galaxy_data$head$Npart[3]+galaxy_data$head$Npart[4])], galaxy_data$part$z[(galaxy_data$head$Npart[3]+1):(galaxy_data$head$Npart[3]+galaxy_data$head$Npart[4])], pch = '.', xlim = c(-20, 20), ylim = c(-20, 20), xlab = "x-position, kpc", ylab = "z-position, kpc", col = rgb(0, 0, 0, 0.05))
points(galaxy_data$part$x[1:galaxy_data$head$Npart[3]], galaxy_data$part$z[1:galaxy_data$head$Npart[3]], col = rgb(1, 0, 0, 0.05), pch = '.')
```

## Analysing the simulation

To begin, we can use the `sim_analysis()` function to calculate a few useful quantities for our model. Using this function, we can assess several spatial and kinematic properties such as:

* the mass distribution
* the `log(`density`)` distribution
* the circular velocity distribution
* the velocity anisotropy ($\beta$) distribution
* the Bullock spin parameter ($\lambda$) distribution

```{r}
sim_data = sim_analysis(filename = "~/SimSpin/inst/extdata/S0_vignette", 
                        bin_type = "r",
                        ptype    = NA,  # considering all particles
                        rmax     = 200, # maximum radius considered, kpc
                        rbin     = 200) # number of radial bins considered
```

When using `sim_analysis()`, we specify the snapshot `filename`, the type of particle we want to analyse `ptype = NA (all), 1 (gas), 2 (dark matter), 3 (disc), 4 (bulge), 5 (stars), 6 (boundaries)` or any present combination, `c(3,4)`, the maximum radius `rmax` in kpc we want to consider and the number of radial bins that we wish to divide the galaxy into, `rbin`. In the above example, all particles are grouped into bins of width `rmax / rbin = 1` kpc. Because we have specified `binddir = "r"` our bins are spherical shells. If we wished to study the distributions of certain components in cylindrical coordinates, we would specify either `bindir = "cr"` (cylindrical radial coordinated) or `="z"` (for 1D coordinates off the surface of the disc).

Below, a few of the possible distributions are plotted using the data produced by `sim_analysis()`.

``` {r, echo=FALSE, fig.width=3, fig.height=3}
magicaxis::magplot(sim_data$r, sim_data$Mass, type="l", lwd=3, col="red", xlab="r, kpc", ylab=expression("Mass, 10"^{10}*" M"['\u0298']))
magicaxis::magplot(sim_data$r, sim_data$logp, type="l", lwd=3, col="blue", xlab="r, kpc", ylab=expression("log("*paste(rho)*"),  10"^{10}*" M"['\u0298']*"kpc"^{-3}))
magicaxis::magplot(sim_data$r, sim_data$B, type="p", pch=20, col="orange", xlab="r, kpc", ylab=expression(paste(beta)), ylim=c(-4, 1))
magicaxis::magplot(sim_data$r, sim_data$lambda, type="l", lwd=3, col="green", xlab="r, kpc", ylab=expression(paste(lambda)))
```

Alternatively, you can consider single components of the model. For example, if we wished to examine the properties of the galaxy disk, we specify `ptype = 3`. The same could be done to examine the bulge by specifying `ptype = 4`. If you wish to examine a combination of parameters, this is simply specified by `ptype = c(2,3)` to give, for example, the dark matter and disc components - though this vignette galaxy model contains no dark matter so this will result in an error as shown. 

```{r, error=TRUE, purl=FALSE}
disk_data  = sim_analysis(filename = "~/LambdaR/inst/extdata/S0_vignette", 
                          ptype    = 3,      # considering just the disk particles
                          rmax     = 200, 
                          rbin     = 200)

bulge_data = sim_analysis(filename = "~/LambdaR/inst/extdata/S0_vignette", 
                          ptype    = 4,      # considering just the bulge particles
                          rmax     = 200, 
                          rbin     = 200)

dm_data    = sim_analysis(filename = "~/LambdaR/inst/extdata/S0_vignette", 
                          ptype    = c(2,3), # considering just the dark matter particles
                          rmax     = 200, 
                          rbin     = 200)
```
``` {r, echo=FALSE, fig.width=3, fig.height=3} 
magicaxis::magplot(disk_data$r, disk_data$Mass, type="l", lwd=3, col="red", xlab="r, kpc", ylab=expression("Mass, 10"^{10}*" M"['\u0298']), ylim=c(0,0.65))
legend("bottomright", inset=c(0.05,0.05),c("Disk"), bty="n", cex=0.9)

magicaxis::magplot(bulge_data$r, bulge_data$Mass, type="l", lwd=3, col="blue", xlab="r, kpc", ylab=expression("Mass, 10"^{10}*" M"['\u0298']), ylim=c(0,0.65))
legend("bottomright", inset=c(0.05,0.05),c("Bulge"), bty="n", cex=0.9)
```

## "Observing" the simulation

An important method of this package is to take mock integral field unit (IFU) observations of galaxy models. The following sections will take you through how to create a mock IFU data cube for your simulation. The functions attempt to be as general as possible, with options allowing the user to specify the shape of the CCDs within your chosen telescope, the field of view, the spatial and velocity pixel scale and central wavelength of the filter used during the "observation". Once the IFU data cube has been created, this can be analysed as an observer would real data and the spin parameter $\lambda_R$ and the observed inclination can be calculated. 

### Preparing the simulation data for observation

In order to arrange the data in the way that a telescope would collect it, we use the `obs_data_prep()` function. Below, we prepare the `S0_vignette` model for observation using the blue filter on SAMI of the galaxy inclined at $75^o$ at redshift $z = 0.1$. 

```{r} 
SAMI_obs = obs_data_prep(filename     = "~/LambdaR/inst/extdata/S0_vignette",
                         ptype        = NA,         # considering all particles
                         r200         = 200,        # virial radius, kpc
                         z            = 0.1,        # galaxy redshift
                         fov          = 15,         # telescope field of view, arcseconds
                         ap_shape     = "circular", # arrangement of the CCDs
                         central_wvl  = 4800,       # central filter wavelength, angstroms
                         lsf_fwhm     = 2.65,       # fwhm of the line spread function, angstroms
                         pixel_sscale = 0.5,        # spatial pixel scale, arcseconds
                         pixel_vscale = 1.04,       # velocity pixel scale, angstroms 
                         inc_deg      = 75)         # projected inclination, degrees
```

Alternatively, we could observe our model using MaNGA or SAURON. 

```{r} 
MaNGA_obs  = obs_data_prep(filename     = "~/LambdaR/inst/extdata/S0_vignette",
                           ptype        = NA,  
                           r200         = 200,
                           z            = 0.1,         
                           fov          = 32,          
                           ap_shape     = "hexagonal", 
                           central_wvl  = 5200,
                           lsf_fwhm     = 1.75,
                           pixel_sscale = 0.5,
                           pixel_vscale = 0.5, 
                           inc_deg      = 75)

SAURON_obs = obs_data_prep(filename     = "~/LambdaR/inst/extdata/S0_vignette",
                           ptype        = NA,   
                           r200         = 200,
                           z            = 0.1,         
                           fov          = 37,          
                           ap_shape     = "square", 
                           central_wvl  = 4500,
                           lsf_fwhm     = 3.25,
                           pixel_sscale = 0.5,
                           pixel_vscale = 1.1, 
                           inc_deg      = 75)       
```

The output from this function is a list that contains the simulation data in a format you need to make a mock IFU data cube. First, it gives a `data.frame` which contains all of the particle data from the original Gadget snapshot file along with the projected line of sight spatial (`$galaxy_obs$z_obs` and `$galaxy_obs$r_obs`) and velocity (`$galaxy_obs$vy_obs`) properties. These can be used to plot the particles that would be viewed by the telescope, as shown below. It also returns the number and size of spatial bins in kpc and arcseconds (`$sbin`, `$sbinsize` and `$pixsize`), the velocity bins (`$vbinsize`) and the angular size of each pixel for easy conversion (`$angular_size`) as required for constructing the IFU cube.

``` {r, echo=FALSE, fig.width=2.25, fig.height=3} 
magicaxis::magplot(SAMI_obs$galaxy_obs$x, SAMI_obs$galaxy_obs$z_obs, pch = '.', xlim = c(-40, 40), ylim = c(-40, 40), xlab = "x-position, kpc", ylab = "y-position, kpc", main="SAMI")

magicaxis::magplot(MaNGA_obs$galaxy_obs$x, MaNGA_obs$galaxy_obs$z_obs, pch = '.', xlim = c(-40, 40), ylim = c(-40, 40), xlab = "x-position, kpc", ylab = "y-position, kpc", main="MaNGA")

magicaxis::magplot(SAURON_obs$galaxy_obs$x, SAURON_obs$galaxy_obs$z_obs, pch = '.', xlim = c(-40, 40), ylim = c(-40, 40), xlab = "x-position, kpc", ylab = "y-position, kpc", main="SAURON")
```

### Constructing an IFU data cube

Using the information output from the `obs_data_prep()` function, we can then construct an IFU data cube using the `ifu_cube()` function. The `threshold` parameter specifying the minimum number of counts in each data cube bin. 

```{r} 
SAMI_cube_phys = ifu_cube(obs_data     = SAMI_obs,  # data.frame of observed particle data
                          threshold    = 25)        # surface brightness threshold, mag/arcsec^2           

```

``` {r, echo=FALSE, fig.width=5, fig.height=5, message=FALSE, warning=FALSE, results="hide", fig.align="center"}
png(file="SAMI_cube_phys%02d.png", width=456, height=500)
for (i in 1:length(SAMI_cube_phys$vbin_labels)){
  magicaxis::magimage(SAMI_cube_phys$cube[,,i], xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)))
  legend("topright", inset=c(0.05,0.05), paste("v = ", round(SAMI_cube_phys$vbin_labels[i], digits=3)), text.col = "white", bty="n", cex=0.9)
}
dev.off()

system("convert -delay 40 *.png SAMI_cube_phys.gif")
file.remove(list.files(pattern=".png"))
```
![Demontrating the cube produced by the `ifu_cube()` function, moving through each velocity plane.](SAMI_cube_phys.gif)

The animation above demonstrates the sequential planes of the IFU data cube that is produced by the function. The `$cube` that is produced by the function is a 3D array of counts; each frame represents the particles that have velocities that fall into the specified `vbin` and displays the spatial arrangement of particles that fall into each `sbin` grid cell. 

The spatial and velocity midpoints of each bin are stored in `$xbin_labels`, `$zbin_labels` and `$vbin_labels`. These outputs can then be fed into further functions to calculate the observed spin parameter $\lambda_R$. 

### Finding the effective radius, $R_{eff}$

First, however, it is necessary to find the effective radius of the observed galaxy in order to know what radius $\lambda_R$ should be measured at. This can be done using the `find_reff()` function and the output axis ratio from the `ifu_cube()` function. 

```{r} 
SAMI_reff = find_reff(filename   = "~/LambdaR/inst/extdata/S0_vignette", 
                      ptype      = NA,                        # considering all particles
                      r200       = 200,                       # virial radius, kpc
                      inc_deg    = 75,                        # inclination of galaxy, degrees
                      axis_ratio = SAMI_cube_phys$axis_ratio) # axis ratio of the galaxy, kpc
```

The output of this is the equivilant of the half light radius at which half of the total luminosity output of the galaxy is emitted. As we have only particle data, we use particle counts to define this effective radius. 

### Calculating $\lambda_R$

Once we have constructed the IFU data cube and determined the $R_{eff}$, the observable spin parameter $\lambda_R$ can be calculated. This is done using the `obs_lambda()` function. 

```{r} 
SAMI_lambda = obs_lambda(ifu_datacube   = SAMI_cube_phys,    # output from ifu_cube() function
                         reff_axisratio = SAMI_reff,         # reff at given inclination, kpc
                         sbinsize       = SAMI_obs$sbinsize) # sbin size, kpc
                         

SAMI_lambda$obs_lambdar # the observed lambda_R spin parameter
```

This function will return the observed spin parameter (`$obs_lambdar`), three IFU images (the `$counts_img`, `$velocity_img` and `$dispersion_img`) and the coordinates of an ellipse marking the radius at which the $\lambda_R$ parameter has been measured (`$reff_ellipse`). 

``` {r, echo=FALSE, fig.width=3.25, fig.height=3.85} 
magicaxis::magimage(SAMI_lambda$counts_img, xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)))
lines(SAMI_lambda$reff_ellipse[,1], SAMI_lambda$reff_ellipse[,2], col="red", lwd=3, xaxt="n", yaxt="n", ann=FALSE)
legend("topleft", "Counts", text.col = "black", bty="n", cex=0.9)
fields::image.plot(legend.only = TRUE, zlim = range(c(SAMI_lambda$counts_img)), col = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), horizontal = TRUE)

magicaxis::magimage(SAMI_lambda$velocity_img, xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), magmap=FALSE, scale="linear", zlim = range(c(SAMI_lambda$velocity_img)))
lines(SAMI_lambda$reff_ellipse[,1], SAMI_lambda$reff_ellipse[,2], col="red", lwd=3, xaxt="n", yaxt="n", ann=FALSE)
legend("topleft", "Velocity", text.col = "black", bty="n", cex=0.9)
fields::image.plot(legend.only = TRUE, zlim = range(c(SAMI_lambda$velocity_img)), col = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), horizontal = TRUE)

magicaxis::magimage(SAMI_lambda$dispersion_img, xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), magmap=FALSE, scale="linear", zlim = range(c(SAMI_lambda$dispersion_img)))
lines(SAMI_lambda$reff_ellipse[,1], SAMI_lambda$reff_ellipse[,2], col="red", lwd=3, xaxt="n", yaxt="n", ann=FALSE)
legend("topleft", "Dispersion", text.col = "black", bty="n", cex=0.9)
fields::image.plot(legend.only = TRUE, zlim = range(c(SAMI_lambda$dispersion_img)), col = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), horizontal = TRUE)
```

If the effective radius specified is larger than the aperture, the function will return a warning.

```{r}
SAMI_lambda_warning = obs_lambda(ifu_datacube   = SAMI_cube_phys,    # output from ifu_cube() function
                                 reff_axisratio = 10 * SAMI_reff,    # reff at given inclination, kpc
                                 sbinsize       = SAMI_obs$sbinsize) # sbin size, kpc
```

It is possible to introduce blurring due to beam smearing and seeing conditions at this point in the process. This blurring is introduced by convolving each velocity frame of the IFU data cube with a Gaussian or Moffat PSF kernel. 

```{r} 
SAMI_lambda_blur = obs_lambda(ifu_datacube   = SAMI_cube_phys,        # output from ifu_cube() function
                              reff_axisratio = SAMI_reff,             # reff at given inclination, kpc
                              sbinsize       = SAMI_obs$sbinsize,     # sbin size, kpc
                              psf            = "Gaussian",            # or "Moffat" 
                              fwhm           = 1.0,                   # arcseconds
                              angular_size   = SAMI_obs$angular_size) # kpc/arcsecond
                                      
```
``` {r, echo=FALSE, fig.width=3.25, fig.height=3.85} 
magicaxis::magimage(SAMI_lambda$counts_img, xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)))
legend("topleft", "W/O Beam Smear", text.col = "white", bty="n", cex=0.9)
fields::image.plot(legend.only = TRUE, zlim = range(c(SAMI_lambda$counts_img)), col = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), horizontal = TRUE)

magicaxis::magimage(SAMI_lambda_blur$counts_img, xaxt="n", yaxt="n", ann=FALSE, col=rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)))
legend("topleft", "W/ Beam Smear", text.col = "white", bty="n", cex=0.9)
fields::image.plot(legend.only = TRUE, zlim = range(c(SAMI_lambda$counts_img)), col = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdYlBu"))(100)), horizontal = TRUE)
```

### Correcting $\lambda_R$ for inclination

It is well understood that the observed value of $\lambda_R$ is very sensitive to the inclination at which the galaxy is observed. Due to this, there is an "inclination correction" that can be applied to help mitigate the impact of the inclination.

As we have chosen the angle at which we wish to observe our galaxy model, we already know the true inclination of the system. But when making a true observation, this is not the case. It is interesting to evaluate how the observable inclination measurement impacts the value of $\lambda_R$ that is returned in comparison to the value corrected for the true inclination specified at the start. To do so, we use the `inc_correct()` function. 

First, this function determines the observed inclination of the galaxy using the equation:

$$ cos(i) = \sqrt{\frac{(b/a)^2 - q_0^2}{1 - q_0^2}}, $$
where $a$ and $b$ are the semi-major and semi-minor axes as output by \code{ifu_cube()} and $q_0$ is the intrinsic axial ratio of an edge on galaxy. The value of this factor is highly uncertian for observers and ranges from \sim 0.1 - 0.65; in this case, we use $q_0$ = 0.1 for "late" type galaxies and $q_0$ = 0.6 for "early" type galaxies. 

Once the observed inclination has been approximated, the inclination corrected $\lambda_R$ can be calculated using the following expression:

$$\lambda_{corrected} = \frac{\lambda_{R, obs}}{C} \frac{1}{\sqrt{1 - \lambda_{R, obs}^2 (1 - 1/C^2)}},$$

where,

$$C = \frac{sin(i)}{\sqrt{1 - v_{aniso} cos(i)}},$$

$v_{aniso}$ is the velocity anisotropy and $i$ is the inclination.

```{r} 
SAMI_inc_lambda = inc_correct(inc_deg      = 75,                           # true inclination, degees
                              galaxy_class = "late",                       # or "early"
                              axis_ratio   = SAMI_cube_phys$axis_ratio,    # axis ratio of galaxy
                              obs_lambdar  = SAMI_lambda_blur$obs_lambdar) # measured lambda_R
```

If `v_aniso` is not specified, the function will return an array containing the true and observationally corrected $\lambda_R$ values at 4 different values, $v_{aniso} = 0, 0.2, 0.4, 0.6$. If, instead, this parameter is directly specified, a vector is returned containing the true and observationally corrected values at those chosen values of `v_aniso`:

```{r} 
inc_correct(inc_deg      = 75,                           # true inclination, degees
            galaxy_class = "late",                       # or "early"
            axis_ratio   = SAMI_cube_phys$axis_ratio,    # axis ratio of galaxy
            obs_lambdar  = SAMI_lambda_blur$obs_lambdar, # measured lambda_R
            v_aniso      = 0.3)                          # velocity anisotropy
```

### Considering $\lambda_R$

Once we have calculated all of these parameters, we can see how the measured $\lambda_R$ value compares to the true spin parameter we measure from the simulation. Obviously this is very dependent on the inclination angle at which we measure the galaxy and the accuracy to which we can measure the inclination observationally.

``` {r, echo=FALSE, fig.width=5, fig.height=5, fig.align="center"}
magicaxis::magplot(sim_data$r, sim_data$lambda, type="l", lwd=3, col="green", xlab="r, kpc", ylab=expression(paste(lambda)), ylim = c(0, 0.7))
abline(h=SAMI_inc_lambda$obs_lambda[1], col = "blue", lwd=3)
abline(h=SAMI_inc_lambda$obs_lambda[2], col = "red", lwd=3)
abline(h=SAMI_lambda_blur$obs_lambdar, col="black", lwd=3)
legend("topright", inset=c(0.05,0.05), c(expression("Observed "*paste(lambda)[R]), expression("True inc correct "*paste(lambda)[R]), expression("Obs inc correct "*paste(lambda)[R])), lty = c(1,1,1), col = c("black", "blue", "red"), bty="n", lwd=c(3,3,3), cex=0.9)
```

This package is designed to help astronomers investigate the observational limitations of measuring the spin parameter of a galaxy. This vignette has shown a series of possible steps to do so. 
